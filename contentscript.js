// Try to find diff file line numbers on the current page and link them their locations
function updateLineNumberButtons() {
	$('.linkable-line-number').each(function(i, el) {
    	el.onclick = function(mouseEvent) {
      		var line = $.trim(el.innerText);
      		if(parseInt(line)) {
        		// `line` seems to be a valid line number. Generate the URL to view the file at this line.
        		var baseURL = $(el).first().parentsUntil('.diff-view').last().find('.button-group').children(0).attr('href');
            var lineParameter = '#L' + line + '-' + line;

        		// If the used presses the `alt` key we try to open the file for editing:
        		if(mouseEvent.altKey) {
          			var branch = getPullRequestHeadBranch();

          			if(branch) {
            			baseURL = baseURL.replace(/blob\/[a-z0-9]+/, 'edit/' + branch);
            			lineParameter = '?gotoLine=' + line; 
          			} else {
            			alert('Sorry, you can\'t edit this file because you\'re not on a named branch');
          			}
        		}

        		window.open(baseURL + lineParameter, '_blank');
      		}
    	}
  	})
}


// Read a URL parameter from the current window URL
function getURLParameter(sParam) {
	var sPageURL = window.location.search.substring(1);
  	var sURLVariables = sPageURL.split('&');
    	for (var i = 0; i < sURLVariables.length; i++) {
        	var sParameterName = sURLVariables[i].split('=');
        	if (sParameterName[0] == sParam) {
            	return sParameterName[1];
        }
    }
}


// Check for a valid `gotoLine` URL parameter (generated by github magic) and try to find the github
// editor window in order to jump to the specified line.
function gotoLine() {
 	var line = parseInt(getURLParameter('gotoLine'));
 	if(line) {
		$(window).load(function() {
   			location.href = 'javascript:editor.ace.gotoLine(' + line + ', 0, false);' +
   			                ' editor.ace.scrollToRow(' + (line-1) + ');'
    	});
  	}  
}


// Returns `true` if we are on a Github Pull Request page
function isPullRequestPage() {
  var pullRequestMatcher =/pull\/[0-9]+(\/files)?$/;
  return pullRequestMatcher.exec(window.location.pathname);
}


// Returns a Github URL
function getFileURL(command, fork, branch, file)
{
  return window.location.origin + '/' +  
         fork +
         window.location.pathname.match(/\/[-A-Za-z0-9_]+/g)[1] + '/' + 
         command + '/' + branch + '/' + file;
}


// Returns a Github blame URL
function getBlameURL(fork, branch, file)
{
  return getFileURL('blame', fork, branch, file);
}


// Returns the head branch of the current Pull Request
function getPullRequestHeadBranch() {
    return $('.pull-description .commit-ref .css-truncate-target')
      .last()
      .text();
}


// Returns the fork of the head branch of the current Pull Request
function getPullRequestHeadBranchFork() {
    var fork = $('.pull-description .commit-ref .css-truncate-target')
                .last()
                .prev()
                .text();

    // If the head and base branch is in the same fork, we need to read the fork name differently:
    if (!fork) {
      fork = window.location.pathname.match(/\/[-A-Za-z0-9_]+/g)[0];
      fork = fork.substring(1, fork.length);
    }
    return fork;
}


// Blame cache dictionary
//    Key: github blame URL
//    Value: Dictionary StartLine --> CommitInfo
var gitBlameCache = {};


// Read a commit info from the blame cache
function getCommitInfo(file, lineNumber) {

  // Go up in the file until we find the first line of a commit
  var i = lineNumber;
  while (  i >= 0 && !(i in gitBlameCache[file]) ) i--;

  if (i >= 0)
    return gitBlameCache[file][i];
  else
    return undefined;
}


// Performs git blame on a file in a branch and 
// calls the callback with parameters `file`, `startLineNumber` and `commitMessage`
function blame(fork, branch, file, lineNumber, callback) {

  // Do request the blame if it was already requested
  if (file in gitBlameCache) {
    callback();
    return;
  }

  gitBlameCache[file] = {};

  var blameURL = getBlameURL(fork, branch, file);  
  console.log(blameURL);
  $.ajax({
    url: blameURL,
    success: function(data, textStatus, jqXHR) {
      console.log('Received blame for ' + file);
      $(data).each(function(){ 
        if ($(this).is('div')) {
          var sections = $('.highlight .section-first', this);

          for (var i=0; i<sections.length; i++)
          { 
            var author = $('.commitinfo', sections[i]).find('[rel="author"]').html();
            if (!author) {
              author = $('.commitinfo', sections[i]).find('a').last().html();
            }

            var commitDate = $('.commitinfo .date', sections[i]).html();
            var commitMessage = $('.commitinfo .message', sections[i]).attr('title');
            var startLineNumber = parseInt($('.line-number', sections[i]).html());

            if (i<sections.length-1) {
              var endLineNumber = parseInt($('.line-number', sections[i+1]).html()) - 1;
            } else {
              var endLineNumber = parseInt($('.line-number', this).last().html());
            }

            var commitInfo = {
              author: author, 
              date: commitDate, 
              message: commitMessage,
              startLineNumber: startLineNumber,
              endLineNumber: endLineNumber
            };

            gitBlameCache[file][startLineNumber] = commitInfo;
          }
        }
      });
      callback();
    },
    error: function(jqXHR, textStatus, errorThrown) {
      // In case of an timeout we want to reload the blame again. In all other cases not. E.g.
      // github returns an error if we perform a blame on an image.
      if (textStatus === "timeout") {
        delete gitBlameCache[file];
      }
    }
  });
}


// Returns a string containing the distance of time in words between `from` and now
// Source: https://github.com/drinks/jquery-relative-date/blob/master/jquery.relative-date.js
function distance_of_time_in_words(from) {
  var today = new Date;
  var distance_in_seconds = ((today - Date.parse(from)) / 1000);
  var distance_in_minutes = Math.floor(distance_in_seconds / 60);

  if (distance_in_minutes == 0) { return 'less than a minute ago'; }
  if (distance_in_minutes == 1) { return 'a minute ago'; }
  if (distance_in_minutes < 45) { return distance_in_minutes + ' minutes ago'; }
  if (distance_in_minutes < 90) { return 'about 1 hour ago'; }
  if (distance_in_minutes < 1440) { return 'about ' + Math.round(distance_in_minutes / 60) + ' hours ago'; }
  if (distance_in_minutes < 2880) { return '1 day ago'; }
  if (distance_in_minutes < 43200) { return Math.floor(distance_in_minutes / 1440) + ' days ago'; }
  if (distance_in_minutes < 86400) { return 'about 1 month ago'; }
  if (distance_in_minutes < 525960) { return Math.floor(distance_in_minutes / 43200) + ' months ago'; }
  if (distance_in_minutes < 1051199) { return 'about 1 year ago'; }

  return 'over ' + Math.floor(distance_in_minutes / 525960) + ' years ago';
}


// Augments the `githubLineNumberElement` on mouse hover with the commit info about the line 
function updatePullRequestLineNumberElement(githubLineNumberElement, relativeFileURL, lineNumber) {

  var commitInfo = getCommitInfo(relativeFileURL, lineNumber);

  // Check if we have a valid commit info and if the mouse is still hovering over the element
  if (!commitInfo || !$(githubLineNumberElement).data('mouseIsHovering'))
    return;

  // Remove the hover handler that creates the augmentation
  $(githubLineNumberElement).unbind();
  $(githubLineNumberElement).data('mouseIsHovering', false);

  var top;
  var bottom;

  // Find top most line number of the commit
  var lineNumberElement = $(githubLineNumberElement);
  do {
    top = lineNumberElement.position().top;
    
    var parent = lineNumberElement.parent().prev();
    while (parent.hasClass('inline-comments')) {
      parent = parent.prev();
    }

    lineNumberElement = parent.find('.line_numbers.linkable-line-number').filter('td[id*="R"]');
    var i = parseInt(lineNumberElement.text());
  } while (isNaN(i) === false && i >= commitInfo.startLineNumber)

  // Find bottom most line number of the commit
  lineNumberElement = $(githubLineNumberElement);
  do {
    bottom = lineNumberElement.position().top + lineNumberElement.height();
    
    var parent = lineNumberElement.parent().next();
    while (parent.hasClass('inline-comments')) {
      parent = parent.next();
    }

    lineNumberElement = parent.find('.line_numbers.linkable-line-number').filter('td[id*="R"]');
    var i = parseInt(lineNumberElement.text());
  } while (isNaN(i) === false && i <= commitInfo.endLineNumber)

  var commitBracketHeigth = bottom - top + 2;
  var left = $(githubLineNumberElement).outerWidth() * 2 + 3;

  var commitBracket = $('<div style="' + 
                          'position:absolute;' +
                          'border-radius:3px; border-bottom-right-radius:0px;' +
                          'width:3px; height:' + commitBracketHeigth + 'px; top:' + top + 'px; left:' + left + 'px;' + 
                          'background-color:#557fc5;' +
                        '">').appendTo($(githubLineNumberElement).parent())

  var commitInfo = $('<div style="' + 
                       'position:absolute;' +
                       'max-width:650px; width:650px; left:' + (left + 2) + 'px;' + 
                       'border:1px #557fc5 solid; border-radius:3px; border-top-left-radius:0px;' +
                       'padding:7px 10px;' +
                       'text-align: left;' +
                       'color:#111111;' +
                       'z-index:9999;' +
                       'background-color:#c8dcfc;' + 
                     '">' + commitInfo.message + 
                       '<div style="' +
                         'font-size:smaller;' +
                         'padding-top:6px;' +
                       '">by ' + commitInfo.author + ', ' + distance_of_time_in_words(commitInfo.date) +'</div>' +
                     '</div>')
                   .appendTo($(githubLineNumberElement).parent());

  $(githubLineNumberElement).hover(function () {
    commitInfo.show(); 
    commitBracket.show();
  }, function () {
    commitBracket.hide();
    commitInfo.hide(); 
  });
}


function updatePullRequest() {
  if (isPullRequestPage()) {

    // Modify all line numbers to detect if the mouse hovers over them
    var sourceCodeLines = $('.data').find('.line_numbers.linkable-line-number').filter('td[id*="R"]');

    $.each(sourceCodeLines, function(i, githubLineNumberElement) {
      $(githubLineNumberElement).hover(function () {

        $(githubLineNumberElement).data('mouseIsHovering', true); 

        var relativeFileURL = $(githubLineNumberElement).parents('.file').children('.meta').attr('data-path');
        var lineNumber = parseInt($(githubLineNumberElement).text());

        if (relativeFileURL && lineNumber) {
          blame(getPullRequestHeadBranchFork(),
                getPullRequestHeadBranch(), 
                relativeFileURL,
                lineNumber,
                function() {
                  updatePullRequestLineNumberElement(githubLineNumberElement, relativeFileURL, lineNumber);
                });
        }
      },
      function () {
        $(githubLineNumberElement).data('mouseIsHovering', false);
      });
    });
  }
}


// Detect a github page. I use this method instead of an URL check to support github enterprise
// instances.
function isGithubSite() {
	return $('meta[property="og:site_name"]').attr('content') === "GitHub";
}


// Main function. Executed after on document end (as defined in manifest.json)
if(isGithubSite()) {
	updateLineNumberButtons();
  updatePullRequest();
	gotoLine();
}